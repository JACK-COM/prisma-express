import {
  NO_USER,
  USER_EMAIL_EXISTS,
  USER_SCREENNAME_EXISTS
} from "../constants";
import * as encrypt from "bcryptjs";

import { Authenticator, User } from "@prisma/client";
import { DateTime } from "luxon";
import { CtxUser, context } from "../graphql/context";
import { findFirstUser, upsertUser } from "../services/users.service";
import { slugify } from "../utils";

type PassportUser = {
  // The provider with which the user authenticated (facebook, twitter, etc.).
  provider: string & ("google" | "facebook" | "twitter");
  // A unique identifier for the user, as generated by the service provider.
  id: string;
  // The name of this user, suitable for display.
  displayName: string;
  // User's given name
  name: {
    // The family name of this user, or "last name" in most Western languages.
    familyName: string;
    // The given name of this user, or "first name" in most Western languages.
    givenName: string;
    // The middle name of this user.
    middleName: string;
  };
  // actual email address, type address (home, work, etc.).
  emails?: { value: string; type?: string }[];
  // The URL of the image.
  photos: string[];
};
type UserCallback = (e: Error | string | null, u?: CtxUser) => any;
type CreateOpts = {
  authSource: Authenticator;
  email: string;
  displayName?: string;
  password?: string;
};
type NewUserResult = [Error | null, CtxUser | undefined];

/**
 * @middleware
 * Check password strength for
 * - at least 8 characters
 * - at least 1 uppercase letter, 1 lowercase letter, and 1 number
 * - special characters (optional) */
export function checkPasswordStrength(password: string) {
  if (!password) return false;
  return new RegExp(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$/).test(
    password
  );
}

/** @middleware Regex-check string conforms to email pattern */
export function validateEmailString(email: string) {
  return new RegExp(/^\w{3,}@\w+\.\w+$/).test(email);
}

/** @middleware Verify an argon2 hashed password */
export async function verifyPassword(raw: string, hashed: string) {
  return encrypt.compare(raw, hashed); // argon2 only
}

/** @middleware hash a password */
export async function hashPassword(password: string) {
  return encrypt.hash(password, 10);
}

//** @middleware create reset token */
export async function createResetToken(userId: number) {
  const token = await hashPassword(`${userId}-${Date.now()}`);
  const base64Token = Buffer.from(token).toString("base64");
  const updatedUser = await context.Users.update({
    where: { id: userId },
    data: {
      resetToken: base64Token,
      resetTokenRequested: DateTime.now().toJSDate()
    }
  });
  return updatedUser.resetToken;
}

/**
 * @Helper `CtxUser` generator. This is the `User` object used by our requests: put anything here
 * that either is needed globally or limits requests from the UI */
const toCtxUser = (u: User): CtxUser => ({
  id: u.id,
  email: u.email,
  displayName: u.displayName,
  image: u.image,
  lastSeen: u.lastSeen,
});
/**
 * @Middleware Link social sign-on user to internal account
 * @param user Authenticated user
 * @param done Callback function
 */
export async function verifyFederated(
  src: string,
  profile: PassportUser,
  cb: UserCallback
) {
  // Exit if no emails fetched from auth
  if (!Array.isArray(profile.emails)) return cb(new Error(NO_USER));

  // Retrieve user if they exist
  const [{ value: email }] = profile.emails;
  const opts = { email, authSource: getAuthIssuer(src) };
  const internalUser = await findFirstUser({ email });
  if (internalUser) {
    upsertUser({ ...internalUser, authSource: "google" }); // update last-seen date
    return cb(null, toCtxUser(internalUser));
  }

  // create and return new user
  const [err, user] = await signupNewUser(opts);
  return cb(err, user);
}

/**
 * @Middleware Sign in user with email and password. PassportJS calls this with
 * credentials when a user attempts to sign in with email/password. We check our db
 * to see if the user exists, and respond accordingly.
 * @param email User email
 * @param pwd User password (plaintext)
 * @param cb Callback function
 */
export async function verifyLocal(
  email: string,
  pwd: string,
  cb: UserCallback
) {
  const internalUser = await findFirstUser({ email });
  if (!internalUser) return cb(new Error(NO_USER));

  // Check password match if the user has set one
  if (!internalUser.password)
    return cb(new Error("User has not set a password"));
  const match = await verifyPassword(pwd, internalUser.password);
  if (match) {
    upsertUser({ ...internalUser }); // update last-seen date
    return cb(null, toCtxUser(internalUser));
  }

  // password does not match
  return cb(new Error("Invalid username or password"));
}

/** @Helper Create a new user with username/password credentials */
export async function createUserLocal(o: {
  email: string;
  displayName: string;
  pwd: string;
  cb: UserCallback;
}) {
  const { email, displayName, pwd, cb } = o;
  // Attempt to create user
  const validEmail = validateEmailString(email);
  if (!validEmail) return cb(new Error("Invalid email address"));

  const strongPwd = checkPasswordStrength(pwd);
  if (!strongPwd) return cb(new Error("New Password is not strong enough"));
  if (!displayName) return cb(new Error("Username is required"));

  const [emailUser, screennameUser] = await Promise.all([
    findFirstUser({ email }),
    context.Users.findFirst({ where: { displayName } })
  ]);

  if (emailUser?.email) return cb(new Error(USER_EMAIL_EXISTS));
  if (screennameUser?.displayName) return cb(new Error(USER_SCREENNAME_EXISTS));

  const opts: CreateOpts = {
    email,
    password: pwd,
    displayName,
    authSource: "other"
  };
  const [err, user] = await signupNewUser(opts);
  return cb(err, user);
}

/** @Helper Create a new user if they don't exist in the db */
export async function signupNewUser(opts: CreateOpts): Promise<NewUserResult> {
  const { email, password: rpw = null, authSource } = opts;
  const internalUser = await findFirstUser({ email });
  if (internalUser) return [new Error(USER_EMAIL_EXISTS), undefined];

  // Create new user
  const password = rpw ? await hashPassword(rpw) : null;
  const displayName = opts.displayName || slugify(email.split("@")[0], email);
  const data = { email, password, displayName, authSource };
  const newUser = await upsertUser(data);
  return [null, toCtxUser(newUser)];
}

/**
 * @Helper Get `Authenticator` value for auth issuer
 * @param issuer Issuer from `Passport` (e.g. `https://accounts.google.com`)
 * @returns `Authenticator` value for auth issuer
 */
function getAuthIssuer(issuer: string): Authenticator {
  if (issuer.includes("google")) return "google";
  if (issuer.includes("magic")) return "magiclink";
  return "other";
}
